

			Αρχικά να αναφερθεί ότι ο κώδικας μου σε περίπτωση που υπάρξουν τυχόν προβλήματα βρίσκεται και στα linux της σχολής
		και στο github μου. Το λινκ είναι το εξής: 
		
		ΚΟΜΜΑΤΙ 1ο:
		
		Εντολές για τρέξιμο του κώδικα:
		
		1)cd DiseaseAggregator
		2)make
		3)cd ../project1
		4)make
		5)./diseaseAggregator –w numWorkers -b bufferSize -i input_dir 
		
			Η εργασία χωρίζεται σε δύο μέρη , το ένα καλύπτει τον parent και είναι ο DiseaseAggregator και το άλλο το child-worker 
		που είναι ο φάκελος project1 . Ο worker έχει εκτελεστεί μέσω exec στον DiseaseAggregator και αποτελεί μία μετατροπή της 
		πρώτης εργασίας που παραδόθηκε. Συγκεκριμένα οι αλλάγες που έγιναν όσον αφορά τις δομές είναι η αφαίρεση του σωρού, ο οποίος 
		δε μου χρείαστηκε κάπου, όλα τα άλλα παραμένουν ίδια.  Τα cases μπαίνουν μέσα στα hashtable και τη λίστα αν η εγγραφή είναι enter 
		αλλιώς αν είναι exit αν η ημερομηνία (του φακέλου) είναι σωστή απλά προστίθονται στα δεδομένα του case που βρίσκεται 
		ήδη μέσα στη λίστα, αλλιώς απλά δεν ανανεώνεται η υπόθεση. Οι συνσρτήσεις που πρέπει να υλοποιούνται από τους worker, είναι
		κατασκευασμένες μέσα στο φάκελο Structs και καλούνται μέσα στη ParseCommands η οποία δέχεται την εντολή από το parent και
		καλεί την αντίστοιχη συνάρτηση, η οποία επιστρέφει το μήμυμα στο γονιό για εκτύπωση. Δεν έχει προλάβει να γίνει εδώ η 
		εκτύπωση των στατιστικών στοιχείων όταν εισάγωνται τα δεδομένα στις δομές και η δημιουργία των φακέλων κατά την έξοδο.
		Άλλα προβλήματα που θα συναντηθούν αφορούν τις εκτυπώσεις τις diseaseFrequency ,όπου όταν δε δίνεται χώρα εκτυπώνονται μεν
		συνολικά κρούσματα , όχι όμως όπως αναφερόταν στην εκφώνηση. Επίσης όταν καλείται η exit με το σήμα SIGKILL από τον
		γονιό δεν εφαρμόζεται από τους worker παρόλο που η σύνταξη είναι σωστή(το προσπάθησα με αρκετούς τρόπους και έιχε με όλους
		θέμα) και έτσι δε διαγράφονται τα αρχεία που κάνουν write οι worker.
			Όσον αφορά το parent-DiseaseAggregator δημιουργεί τα δικά του fifos , παίρνει το αρχείο που του δίνουμε από τη γραμμή εντολών
		, το διαβάζει και αποθηκεύει σε μία λίστα τις χώρες που θα υπάρχουν στο subdirectory του , στη συνέχεια της μοιράζει ισόποσα 
		ανάλογα με τον αριθμό των "εργατών" και τους τις στέλνει. Και μετά απλά εκτελούνται οι συναρτήσεις που ζητούνται από το 
		πληκτρολόγιο μέχρι να δωθεί /exit. Εδώ η exit εκτελείται κανονικά και διαγράφονται τα fifos της.
		Εν κατακλείδι θα γράψω ένα description για κάθε αρχείο ώστε να ξέρετε αν θέλετε να βρείτε κάτι που να ψάξετε.
		
		DiseaseAggregator :
			diseaseAggregator.cpp = όλες οι συναρτήσεις επικοινωνίας του γονιού
			List.cpp = λίστα με χώρες που θα χρησιμοποιηθούν απο worker
			
		project1 :
			MainUtils.cpp = Δημιουργία εγγραφών του κάθε εργάτη,έλεγχος και εκέλεση συναρτήσεων γονιού
			Structs.cpp = Υλοποίηση δομών Hashtable και caseList , και των συναρτήσεων τους που καλούνται από τη MainUtils.cpp
			AVL_Heap.cpp = Υλοποίηση AVL δέντρου και συναρτήσεων του , οι οποίες καλούνται από τη Structs.cpp (ΔΕΝ ΕΧΕΙ ΤΟ ΣΩΡΟ ΤΟΝ ΕΒΓΑΛΑ)
			Database.cpp = Περιέχει τη μορφή των εγγραφών , σχετικά αδιάφορη
			
		Τέλος κάτι σημαντικό που θα ήθελα να πω είναι ότι στέλνω την εργασία με τα αρχεία .ο γιατί στους υπολογιστές της σχολής υπήρχε θέμα 
		με την εντολή to_string(η οποία στα UUBUNTU 18.04) τρέχει κανονικά όχι όμως σε εκείνα λόγω παλαιότερης έκδοσης. Επίσης ο φάκελος 
		Read_Write_Fifos απλά αποθηκεύει τα fifo read και write που δημιουργούνται.
		
		
		
			Ερώτημα 2ο:
			
			Μέσα στη DiseaseAggregator υπάρχει και η create_infiles.sh , που είναι το σκριπτ που ζητήθηκε να κάνουμε, δημιουργεί τα αρχεία 
			ακριβώς όπως ζητήθηκαν για να εκετελεστεί το μόνο που χρειάζεται να κάνετε είναι:
			
			1) chmod +x create_infiles.sh
			2) ./create_infiles.sh diseases.txt countries.txt ../input_dir 10 10(ότι αριθμούς θέλετε)
				/create_infiles.sh diseasesFile countriesFile input_dir numFilesPerDirectory numRecordsPerFile
			
			Τα diseases.txt και countries.txt είναι κάποια αρχεία που έφτιαξα εγώ δοκιμαστικά για να το τρέχω άμα θέλετε μπορείτε να τα 
			χρησιμοποιήσετε. Τα id φτιάχνονται με αριθμητική σειρά(έχω σε σχόλια κώδικα που τα κάνει και τυχαία) και επίσης οι τιμές για
			τις ημερομηνίες εξόδου είναι τυχαίες  γιατι δεν ήθελα να είναι το σκριπτ τέλειο για να δω πως το ανβτιμετοπίζει ο κώδικας 
			του ερωτήματος 1. Επίσης τα ονόματα πο διάλεξα πάρθηκαν από ένα άρθρο(τα οποία έφτιαξα μόνος μου χωρίς χρήση έτοιμου κώδικα) 
			με τα πιο συνηθησμένα ονοματεπώνυμα Αμερικανών και δεν είναι τυχαία(το έκανα έτσι όχι γιατί δεν ήξερα αλλά γιατί μου την έδινε το 
			μάτι να βλέπω έτσι τα αρχεία όταν τα χρησιμοποιούσα).
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		